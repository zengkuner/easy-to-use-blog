## 简单总结 Vue2 和 Vue3 的区别

### vue3 新特性

#### 1. 使用 TS 重构

#### 2. 响应式原理

vue2 现有限制：

- 无法检测到对象新的属性添加、删除。
- 无法监听数组的变化。
- 需要深度遍历，浪费内存。

vue3 优化：

vue3 通过函数 reactive()给对象新增一个 proxy 对象监听内部的属性来实现数据监听。

- 允许框架拦截对象上的操作。
- proxy 默认可以支持数组。
- 多层对象嵌套，使用懒代理。

vue2 和 vue3 双向绑定原理的简要对比：

vue2 采用的是**数据劫持**和**发布订阅**相结合的方式，是通过`Object.defineProperty()`实现劫持，每个组件中的 data 选项，在渲染过程中，对 data 中的数据进行遍历，用`Object.defineProperty()`转换为`getter/setter`方法，得知属性发生变化后，再通过监听器`observer`通知订阅者`watcher`，每个`watcher`更新视图。

vue2 这种形式的缺点是无法监听对象的新属性的新增、删除；针对数组需要额外处理（用索引改变数组/直接改变数组长度都无法监听到变化），只监听到这指定的 7 种方法对数组的操作`pop push shift unshift reverse sort splice`，或者`Vue.set(this.arr, index, newValue)`/`this.arr.splice(newLength)`。

vue3 中`Proxy()`是`es6`的构造函数，直接拦截对目标对象的读写。

```javascript
var proxy = new Proxy(target, handler); // 重点是handler，也是一个对象，用于定义拦截行为
```

Proxy 实际上是重载了（`overload`）点运算符，即用自己的定义覆盖了语言的原始定义。

#### 3. 虚拟 DOM

Vue3 新策略将`vdom`更新性能与模板大小解耦，变为与动态节点的数量相关，整体比 vue2 性能提升`2~5`倍。

vue2 中的`vdom`性能瓶颈：

- 虽然 vue 能够保证触发更新的组件最小化，但单个组件部分变化需要遍历该组件的整个`vdom`树。
- 传统`vdom`性能跟模板大小正相关，跟动态节点的数量无关。

vue3 优化工作：

- 将抽象语法树`AST`基于动态节点指令（`if for slot`）切割为嵌套的区块，更新一个块节点的时候，就不需要递归遍历树，可以跟踪平面的数组了，执行开销小了一个数量级。
- 使用编译器`Compiler`主动检测模板中的静态节点，将其提升到`render`函数之外，避免在每次渲染时都重新创建对象，提高内存使用率，减少垃圾回收频率。
- 给元素添加一个追踪标记，无论层级嵌套多深，更新时可以直接遍历动态节点。

#### 4. Tree-Shaking

之前的数据显示，vue2.0 的运行时大小是 22.5kb，vue3.0 在 13.5kb。

vue2 现有限制：并不是每个人都使用框架的所有功能，但仍需要下载、解析相应代码。

Vue3 优化：将大多数全局 API 和内部组件移至 ES 模块导出，treeShaking 更友好。

#### 5. Composition API

函数式风格的入口是`setup()`函数（取代之前的`data()`函数），采用了函数式风格后可以享受如下好处：类型自动推导、减少打包体积。
